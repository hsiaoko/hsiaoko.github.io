---
title: "Compiling Affine Loop Nests for a Dynamic Scheduling Runtime on Shared and Distributed Memory"
collection: publications
permalink: /publication/2016-topc
date: 2016-08-01
venue: 'ACM Transactions on Parallel Computing (TOPC)'
paperurl: 'https://dl.acm.org/authorize?N658060'
citation: 'Roshan Dathathri, Ravi Teja Mullapudi, and Uday Bondhugula, “Compiling Affine Loop Nests for a Dynamic Scheduling Runtime on Shared and Distributed Memory,” Proceedings of the ACM Transactions on Parallel Computing (TOPC), August 2016.'
---
[(Download publication here)](https://www.cs.utexas.edu/~roshan/dynamic_scheduling_topc16.pdf)

### Abstract

Current de-facto parallel programming models like OpenMP and MPI make it difficult to extract task-level dataflow parallelism as opposed to bulk-synchronous parallelism. Task parallel approaches that use point-to-point synchronization between dependent tasks in conjunction with dynamic scheduling dataflow runtimes are thus becoming attractive. Although good performance can be extracted for both shared and distributed memory using these approaches, there is little compiler support for them.

In this article, we describe the design of compiler-runtime interaction to automatically extract coarse-grained dataflow parallelism in affine loop nests for both shared and distributed-memory architectures. We use techniques from the polyhedral compiler framework to extract tasks and generate components of the runtime that are used to dynamically schedule the generated tasks. The runtime includes a distributed decentralized scheduler that dynamically schedules tasks on a node. The schedulers on different nodes cooperate with each other through asynchronous point-to-point communication, and all of this is achieved by code automatically generated by the compiler. On a set of six representative affine loop nest benchmarks, while running on 32 nodes with 8 threads each, our compiler-assisted runtime yields a geometric mean speedup of 143.6x (70.3x to 474.7x) over the sequential version and a geometric mean speedup of 1.64x (1.04x to 2.42x) over the state-of-the-art automatic parallelization approach that uses bulk synchronization. We also compare our system with past work that addresses some of these challenges on shared memory, and an emerging runtime (Intel Concurrent Collections) that demands higher programmer input and effort in parallelizing. To the best of our knowledge, ours is also the first automatic scheme that allows for dynamic scheduling of affine loop nests on a cluster of multicores.